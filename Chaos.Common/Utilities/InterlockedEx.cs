using System.Diagnostics.CodeAnalysis;

namespace Chaos.Common.Utilities;

/// <summary>
///     Provides atomic operations for various types using interlocked methods.
/// </summary>
[ExcludeFromCodeCoverage(Justification = "Unsure how to test this")]
//TODO: figure out how to test this
public static class InterlockedEx
{
    /// <summary>
    ///     Adds two doubles atomically and stores the result in the given reference.
    /// </summary>
    /// <param name="source">The reference to store the result in.</param>
    /// <param name="value">The value to add.</param>
    /// <returns>The new value after the addition.</returns>
    public static double Add(ref double source, double value)
    {
        var newCurrentValue = source;

        while (true)
        {
            var currentValue = newCurrentValue;
            var newValue = currentValue + value;
            newCurrentValue = Interlocked.CompareExchange(ref source, newValue, currentValue);

            if (newCurrentValue.Equals(currentValue))
                return newValue;
        }
    }

    /// <summary>
    ///     Adds two floats atomically and stores the result in the given reference.
    /// </summary>
    /// <param name="source">The reference to store the result in.</param>
    /// <param name="value">The value to add.</param>
    /// <returns>The new value after the addition.</returns>
    public static float Add(ref float source, float value)
    {
        var newCurrentValue = source;

        while (true)
        {
            var currentValue = newCurrentValue;
            var newValue = currentValue + value;
            newCurrentValue = Interlocked.CompareExchange(ref source, newValue, currentValue);

            if (newCurrentValue.Equals(currentValue))
                return newValue;
        }
    }

    /// <summary>
    ///     Atomically sets a reference to a new value generated by a factory function.
    /// </summary>
    /// <typeparam name="T">The type of the reference.</typeparam>
    /// <param name="source">The reference to set the new value to.</param>
    /// <param name="valueFactory">The function to generate the new value.</param>
    /// <returns>The new value set to the reference.</returns>
    public static T SetReference<T>(ref T source, Func<T> valueFactory) where T: class
    {
        var newCurrentValue = source;

        while (true)
        {
            var currentValue = newCurrentValue;
            var newValue = valueFactory();
            newCurrentValue = Interlocked.CompareExchange(ref source, newValue, currentValue);

            if (newCurrentValue.Equals(currentValue))
                return newValue;
        }
    }

    /// <summary>
    ///     Atomically sets an integer value to a new value generated by a factory function.
    /// </summary>
    /// <param name="source">The reference to set the new value to.</param>
    /// <param name="valueFactory">The function to generate the new value.</param>
    /// <returns>The new value set to the reference.</returns>
    public static int SetValue(ref int source, Func<int> valueFactory)
    {
        var newCurrentValue = source;

        while (true)
        {
            var currentValue = newCurrentValue;
            var newValue = valueFactory();
            newCurrentValue = Interlocked.CompareExchange(ref source, newValue, currentValue);

            if (newCurrentValue.Equals(currentValue))
                return newValue;
        }
    }

    /// <summary>
    ///     Atomically sets an unsigned integer value to a new value generated by a factory function.
    /// </summary>
    /// <param name="source">The reference to set the new value to.</param>
    /// <param name="valueFactory">The function to generate the new value.</param>
    /// <returns>The new value set to the reference.</returns>
    public static uint SetValue(ref uint source, Func<uint> valueFactory)
    {
        var newCurrentValue = source;

        while (true)
        {
            var currentValue = newCurrentValue;
            var newValue = valueFactory();
            newCurrentValue = Interlocked.CompareExchange(ref source, newValue, currentValue);

            if (newCurrentValue.Equals(currentValue))
                return newValue;
        }
    }

    /// <summary>
    ///     Atomically sets a double value to a new value generated by a factory function.
    /// </summary>
    /// <param name="source">The reference to set the new value to.</param>
    /// <param name="valueFactory">The function to generate the new value.</param>
    /// <returns>The new value set to the reference.</returns>
    public static double SetValue(ref double source, Func<double> valueFactory)
    {
        var newCurrentValue = source;

        while (true)
        {
            var currentValue = newCurrentValue;
            var newValue = valueFactory();
            newCurrentValue = Interlocked.CompareExchange(ref source, newValue, currentValue);

            if (newCurrentValue.Equals(currentValue))
                return newValue;
        }
    }

    /// <summary>
    ///     Atomically sets a float value to a new value generated by a factory function.
    /// </summary>
    /// <param name="source">The reference to set the new value to.</param>
    /// <param name="valueFactory">The function to generate the new value.</param>
    /// <returns>The new value set to the reference.</returns>
    public static float SetValue(ref float source, Func<float> valueFactory)
    {
        var newCurrentValue = source;

        while (true)
        {
            var currentValue = newCurrentValue;
            var newValue = valueFactory();
            newCurrentValue = Interlocked.CompareExchange(ref source, newValue, currentValue);

            if (newCurrentValue.Equals(currentValue))
                return newValue;
        }
    }

    /// <summary>
    ///     Atomically sets a long value to a new value generated by a factory function.
    /// </summary>
    /// <param name="source">The reference to set the new value to.</param>
    /// <param name="valueFactory">The function to generate the new value.</param>
    /// <returns>The new value set to the reference.</returns>
    public static long SetValue(ref long source, Func<long> valueFactory)
    {
        var newCurrentValue = source;

        while (true)
        {
            var currentValue = newCurrentValue;
            var newValue = valueFactory();
            newCurrentValue = Interlocked.CompareExchange(ref source, newValue, currentValue);

            if (newCurrentValue.Equals(currentValue))
                return newValue;
        }
    }

    /// <summary>
    ///     Atomically sets an unsigned long value to a new value generated by a factory function.
    /// </summary>
    /// <param name="source">The reference to set the new value to.</param>
    /// <param name="valueFactory">The function to generate the new value.</param>
    /// <returns>The new value set to the reference.</returns>
    public static ulong SetValue(ref ulong source, Func<ulong> valueFactory)
    {
        var newCurrentValue = source;

        while (true)
        {
            var currentValue = newCurrentValue;
            var newValue = valueFactory();
            newCurrentValue = Interlocked.CompareExchange(ref source, newValue, currentValue);

            if (newCurrentValue.Equals(currentValue))
                return newValue;
        }
    }
}